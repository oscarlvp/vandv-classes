:numbered:
== Code quality and static analysis

The goal of any software project is to deliver a product of the highest possible quality, or at least it should be. Good software has scarce bugs. However, the notion of quality also characterizes how the product is being built and structured. Observing these aspects should help, in the end, to avoid the introduction of bugs. Diomidis Spinellis in his book _Code Quality: The Open Source Perspective_ <<spinellis2006code>> presents four views of software quality:

Quality in use:: This view is centered in the user experience, that is, how users perceive the software. It is the extent to which users can achieve their goals in a particular environment. It does not care about how the product is built. If a word processor makes it hard to edit a document, then it does not serve it purposes.
External quality attributes:: These attributes manifest themselves in the execution of the program. They characterize how well the product conforms to the specification. Observed failures signal the presence of bugs. Crashes, efficiency problems and alike degrade the external quality fo the software. External quality attributes directly affect the quality in use.
Internal quality attributes:: They characterize the internal structure of the product. According to Martin Fowler, <<fowler2019is>>, internal software quality is impacted by how easy it is to understand the code. This, in turn, impacts how easy it is to maintain the product, add new features, improve and detect errors. Internal quality has a great impact in the external quality of the software.
Process quality:: It is a direct expression of how the software product was built. It is affected by the methodologies, practices. tools, frameworks used to develop the software. A good development process favors actions that improve the internal quality of the product.

In the end, all views of quality are deeply interconnected. The process quality impacts the internal quality. The internal quality affects in turn the external quality which directly affects the user experience.

Several models of software quality attributes have been proposed and standardized throughout the years <<boehm1976quantitative>>, <<iso2011square>>. However they all insist, as the Consortium for IT Software Quality (CISQ) summarizes, that high quality software products must be: 
*reliable* (low risk level in use and low likelihood of potential failures), *efficient*, *secure*, and *maintainable*.

Martin Fowler <<fowler2019is>> explains that, as time goes by and a project becomes more complex, it is harder to add new features. At this point, even small changes require programmers to understand large areas of code. Paying attention to internal quality is crucial to further develop the product. Fowler calls _cruft_ those deficiencies in internal quality that make it harder to modify and extend the system. _Crufts_ are redundant, useless and dysfunctional pieces of code that become obstacles and increase increase maintenance costs. This is also known as _Technical Debt_.

External quality attributes can be observed and improved with the help of testing. Meanwhile internal quality attributes are observed by analyzing the code without executing it, that is, with the help of static code analysis. Some authors consider static analysis as a form of _static testing_. However, Meyer in its principles <<meyer2008seven>> excludes these techniques from the testing umbrella. Either way, static analysis helps to spot potential problems earlier and therefore impacts the testing process.

=== Code quality

Internal quality is assured by good code and good development practices. Good code is easy to understand and maintain. But, what may be easy to understand for one developer might be hard to understand for another, and even for the same developer two weeks after the code was written. Fortunately, the community has gathered and shared practices shown to work well, or not, according to experience. 

==== Coding guidelines

Some good development practices are presented as _coding guidelines_ or _coding conventions_. These are rules that specify how the code should be written so it can be understood by everyone. They may go from how to name a class or a method and how to handle exceptions to how and when to insert blank spaces in the code.

Coding guidelines may be specific to a programming language, to a particular framework, library, or tool, they may even be specific to a company or even a project. There are also guidelines general enough so they could be applied anywhere or guidelines that pursue an specific goal such as reducing security breaches in a program.

===== Naming conventions

[quote, Phil Karlton,  Product Architect at Netscape]
____
There are only two hard things in Computer Science: cache invalidation and naming things.
____ 

Part of the coding guidelines is devoted to help developers know how to name program elements such as classes or methods. These guidelines are different from one language to the other, although they share common ideas. This section contains three examples from Java, C# and Python.

The following <<java-naming-conventions>> is an extract from the Java coding conventions <<oracle1997java>>. This fragment specifies how developers should name classes, interfaces and methods.

[[java-naming-conventions]]
.Java naming conventions for classes, interfaces and methods
====
Class names should be nouns, in mixed case with the first letter of each internal word capitalized. Try to keep your class names simple
and descriptive. Use whole words—avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the
long form, such as URL or HTML).

Interface names should be capitalized like class names.

Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
====

<<java-naming-example>> shows a piece of code respecting the naming conventions form <<java-naming-conventions>>.

[[java-naming-example, Listing {counter:listing}]]
.Listing {listing}. Java code matching naming conventions for classes, interfaces and methods
[source,java]
----
public class ArrayList extends AbstractList implements RandomAccess {
    public void ensureCapacity(int minCapacity) { ... }
}
----

<<csharp-naming-conventions>> contains an extract of the naming conventions for C# <<microsoft2008naming>>. 

[[csharp-naming-conventions]]
.C# naming conventions
====
✔️ DO name classes and structs with nouns or noun phrases, using PascalCasing. This distinguishes type names from methods, which are named with verb phrases.

✔️ DO name interfaces with adjective phrases, or occasionally with nouns or noun phrases.

❌ DO NOT give class names a prefix (e.g., "C").

...

✔️ DO prefix interface names with the letter I, to indicate that the type is an interface.

✔️ DO ensure that the names differ only by the "I" prefix on the interface name when you are defining a class–interface pair where the class is a standard implementation of the interface.
====

There are similarities between the naming conventions for Java and C#. For example, class names should be noun phrases starting with a capital letter and using _PascalCasing_ (Also called _UpperCamelCase_ or _DromedaryCase_). While method names in both languages should be verb phrases indicating an action, in Java developers use _camelCasing_. Notice that, in C#, interfaces should be prefixed with `I` but classes should not be prefixed with `C`. <<csharp-naming-example>> shows a code fragment matching these naming conventions. The `I` prefix helps to quickly differentiate between classes and interfaces.

[[csharp-naming-example, Listing {counter:listing}]]
.Listing {listing}. C# code respecting naming conventions
[source,csharp]
----
public class ComplexNode : Node, IEnumerable {
    public void RemoveNode(Node node) { ... }
}
----

Python developers use conventions to further differentiate method and functions from classes and user defined classes from built-in types <<vanrossum2001style>>. See <<python-naming-conventions>>.

[[python-naming-conventions]]
.Naming conventions for Python
====
Class names should normally use the CapWords convention.
The naming convention for functions may be used instead in cases where the interface is documented and used primarily as a callable.

Note that there is a separate convention for builtin names: most builtin names are single words (or two words run together), with the CapWords convention used only for exception names and builtin constants.

Function names should be lowercase, with words separated by underscores as necessary to improve readability.
====

With this, one can easily infer that `Node` names a class, `str` is a built-in type and `remove_node` is a function.

===== Indentation

In most language extra white spaces do not change the semantics of a program but sure they play an important role in readability. Each language tries to enforce an indentation style, but even for the same language different developers have follow different styles. Keeping a consistent style helps fast delimiting blocks in a program and improves understanding.

<<indentation-examples>> shows three examples of different indentation styles applied to the same fragment of code. Notice how different the program looks in each case.

[[indentation-examples]]
.Examples of indentation styles taken from https://en.wikipedia.org/wiki/Indentation_style[Wikipedia] <<wikipedia2020indentation>>
[cols="a,a,a"]
|===
| *Kernighan & Ritchie*
[source,c]
----
while (x == y) {
    something();
    somethingelse();
}
----
| *Ratliff*
[source,c]
----
while (x == y) {
    something();
    somethingelse();
    }
----
| *Haskell*
[source,c]
----
while (x == y)
  { something()
  ; somethingelse()
  ; 
  }
----
|===

The _Kernighan & Ritchie_ style, also known as "`_the one true brace style_`" and "`Egyptian braces`" was used in the influential book _The C Programming Language_ written by Brian Kernighan and Dennis Ritchie (creator of C). Besides C, this style is also used in C++ and Java. C# however, uses the Allman style, in which the first brace is written in a separated line. The Allman style is also used in Pascal and SQL.

Wikipedia lists nine different indentation styles most of them with additional variants <<wikipedia20202indentation>>.

===== Framework and company specific guidelines

Companies and even communities around a framework or project may impose specific guideline to override or extend language conventions.

Sometimes these guidelines have a concrete goal other than readability. <<microsoft-security-example>> shows an extract of the guidelines Microsoft enforces to write secure code using the .NET framework <<microsoft2018secure>>.

[[microsoft-security-example]]
.Microsoft's secure coding guidelines for the .NET framework.
====
When designing and writing your code, you need to protect and limit the access that code has to resources, especially when using or invoking code of unknown origin. So, keep in mind the following techniques to ensure your code is secure:

- Do not use Code Access Security (CAS).
- Do not use partial trusted code.
- Do not use the AllowPartiallyTrustedCaller attribute (APTCA).
- Do not use .NET Remoting.
- Do not use Distributed Component Object Model (DCOM).
- Do not use binary formatters.
====

<<google-conventions>> shows how Google extends the Java coding conventions to their own projects <<google2020java>>.

[[google-conventions]]
.Google conventions for Java
====
When a reference to a static class member must be qualified, it is qualified with that class's name, not with a reference or expression of that class's type.
[source, java]
----
Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very bad
----
====

===== Should conventions be always enforced?

Conventions are created to set a common ground for understanding. This is specially useful when learning a new language, for a newcomer and to ease the collaboration between different developers in a project. However, there are cases in which strictly following these conventions actually has the opposite effect. For example, when dealing with legacy code that followed different guidelines, it is better to stick to the practices in place rather than introducing new conventions. 

In any case, the ultimate goal must be to write consistent code that can be understood for all team/project members. Common sense is always the best guideline.

<<microsoft-base-name>> explains how to name extending classes with respect to the base class, but it also wars against over-use <<microsoft2008naming>>.

[[microsoft-base-name]]
.Microsoft's guideline to name extending classes with a warning on when not to use it 
====
✔️ CONSIDER ending the name of derived classes with the name of the base class.

This is very readable and explains the relationship clearly. Some examples of this in code are: ArgumentOutOfRangeException, which is a kind of Exception, and SerializableAttribute, which is a kind of Attribute. However, it is important to use reasonable judgment in applying this guideline; for example, the Button class is a kind of Control event, although Control doesn’t appear in its name.
====

<<python-guidelines-warning>> shows an extract from the Python coding guidelines stressing the idea that keeping consistency is more important than following the guidelines <<vanrossum2001style>>.

[[python-guidelines-warning]]
.Python guidelines on consistency and guidelines applications
====
A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.

However, know when to be inconsistent -- sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask!

In particular: do not break backwards compatibility just to comply with this PEP!
====

==== Code Smells and AntiPatterns

Thorough the years, developers have identified patterns of code that usually become symptoms of hidden problems affecting the quality of the software. Such code patterns are known as _Code Smells_, a term coined by Kent Beck and first presented in Martin Fowler's _Refactoring_ book <<fowler2006codesmells>>.

Code smells do not always lead to a problem or a bug. But, in most, cases, their presence makes the code harder to understand and maintain, and in Fowler's words "`they are often an indicator of a problem rather than the problem themselves`". Code smells can be eliminated by refactoring, that is, restructuring the program to make it simpler.

The https://sourcemaking.com/[Source Making Blog] presents a list of well known code smells and how they could be solved <<source2020smells>>. Internet is full with such lists they might differ on the (generally catchy) name they use to categorize a smell and some might miss one or two patters.

The following is a small sample of that list.

Long method:: A method that contains too many lines of code or too many statements. Long methods tend to hide unwanted duplicated code and are harder to maintain. It can be solved by splitting the code in shorter methods easier to reuse, maintain and understand. <<long-method-example>> shows a fragment taken from <<glover2006monitoring>> of nearly 20 lines of code. It is already a big chunk code, but it comes for a very large method of more than 350 lines. This is a clear, and rather extreme example of this code smell.
+
[[long-method-example, Listing {counter:listing}]]
.Listing {listing}. An already large fragment of code from a method of more than 350 lines. Taken from <<glover2006monitoring>>
[source, java]
----
if (entityImplVO != null) {
  List actions = entityImplVO.getEntities();
  if (actions == null) {
     actions = new ArrayList();
  }
  Iterator enItr = actions.iterator();
  while (enItr.hasNext()) {
    entityResultValueObject arVO = (entityResultValueObject) actionItr
     .next();
    Float entityResult = arVO.getActionResultID();
    if (assocPersonEventList.contains(actionResult)) {
      assocPersonFlag = true;
    }
    if (arVL.getByName(
      AppConstants.ENTITY_RESULT_DENIAL_OF_SERVICE)
         .getID().equals(entityResult)) {
      if (actionBasisId.equals(actionImplVO.getActionBasisID())) {
        assocFlag = true;
      }
    }
    if (arVL.getByName(
     AppConstants.ENTITY_RESULT_INVOL_SERVICE)
      .getID().equals(entityResult)) {
     if (!reasonId.equals(arVO.getStatusReasonID())) {
       assocFlag = true;
     }
   }
 }
}else{
  entityImplVO = oldEntityImplVO;
}
----

Large class:: A class containing too many methods, fields and lines of code. Large classes can be split into several classes and even into a hierarchy in which each smaller class has a very well defined purpose.

Long parameter list:: A method with a long list of parameters is harder to use. Parameters could be replaced by method calls or passing complete objects.

Primitive obsession:: Abuse of primitive types instead of creating one's own abstractions.

Temporary fields:: Fields in classes that are used only under certain circumstances in one or very few methods, otherwise they are not used. These fields could be promoted most of the times to local variables.

Feature envy:: A method that accesses the data of another object more than its own data. This method's behavior will probably better placed in the class of the external object.

Code smells are very well localized program fragments. However, there are more global patterns that are often used as solutions to a problem but they may bring more harm than benefits and are better to avoid. These bad solutions are described as _AntiPatterns_. The same https://sourcemaking.com/[Source Making Blog] provides an interesting list of them AntiPatterns can be related to coding practices, software architecture designs and even related to the management of a project. Identifying these bad solutions helps also in finding a better alternative <<source2020anti>>.

Here are some examples:

Golden Hammer:: Using a single tool to solve most problems even when it is not the best alternative. Leads to inferior performance and less suited solutions, requirements are accommodated more to match the tool than what users may need, design choices are dictated by the tool's capabilities and new development relies heavily in the tool.

Cut-And-Paste Programming:: This one is self-descriptive: code is reused by copying and pasting fragments in different places. In the case that the originally copied code has a bug, then the issue will reoccur in all places where the code was pasted and it will be harder to solve.

Swiss Army Knife:: An excessively complex class interface attempting to provide for all possible uses of the class. These classes include too many method signatures for a single class. It denotes an unclear abstraction or purpose.

Design By Committee:: A software design, usually from a committee, is so complex and so full of different features and variants that it becomes impossible to complete in a reasonable lapse of time.

==== Code Metrics

Many code smells are vague in their formulation. For example: How can we tell that a method or a class is too long that should be split? Or, how can we tell that two classes are too coupled together so their functionalities should be merged or rearranged? The identification of such potential issues requires concrete measurements for the method length or the coupling between classes. These are known as _code metrics_.

Code metrics are quantitative characterizations or features of the code. They help to assess the structural quality of the software and provide an effective and customizable way to automate the detection of potential code issues. Metrics help to improve the development process.

===== Lines of Code

The simplest code metric is, maybe, the number of _Lines of Code_ (LoC) of a method.footnote:[Sometimes code metrics are presented for _operations_ instead of methods. _Operations_ are indeed methods but the term is broader to escape from the Object-Oriented terminology and reach other programming paradigms.] 

LoCs can be used to compare the length of the methods in a project. It helps to detect those methods that are too long when compared to a given threshold. However, this threshold depends on the development practices used for the project. The programming language as well as the frameworks and libraries supporting the code do have an impact on the length of the methods. For example, a small study made by Jon McLoone from Wolfram <<mcloone2012code>>, observed in http://rosettacode.org/wiki/Rosetta_Code[Rosetta Code] programs that _Mathematica_ requires _less than a third of the length of the same tasks written in other languages_.

Including blank lines or lines with comments in the metric may be misleading for its purposes. Therefore, LoC is often referred as _Physical Lines of Code_ while developers also measure _Logical Lines of Code_ (LLoC) which counts the number of programming language statements in the method. 

===== Cyclomatic Comprexity

A method with many branches and logical decisions is, in general, hard to understand. This affects the maintainability of the code. Back in 1976, Thomas J. McCabe  proposed a metric to assess the complexity of a program <<mccabe1976complexity>>. McCabe's original idea was to approximate the complexity of a program by computing the _cyclomatic number_ of its control flow graph. This is why the metric is also known as _McCabe's Cyclomatic Complexity_. The goal of the metric was to provide a quantitative basis to determine whether a software module was hard to understand, maintain and test.
 
A sequence of code instructions, and by extension the body of a method, could be represented by a directed graph named _control flow graph_. The procedure is as follows:
 - Initially, the graph has two special nodes: the _start_ node and the _end_ node.
 - A sequence of instructions with no branches is called a _basic block_. Each basic block becomes a node of the graph.
 - Each branch in the code becomes an edge. The direction of edge coincides with the direction of the branch.
 - There is an edge from the start node to the node with the first instruction.
 - There is an edge from all nodes that could terminate the execution of the code, to the end node.

For example, the method in <<max-method>> computes the maximum of three given integers. The control flow for this method is shown in <<control-flow-max-method>>.

[[max-method, Listing {counter:listing}]]
.Listing {listing}. A method that computes the maximum between three given integers
[source, java]
----
public static int max(int a, int b, int c) {
    if (a > b) {
        if(a > c) {
            return a;
        }
        else {
            return c;
        }
    }
    else {
        if (b > c) {
            return b;
        }
        else {
            return c;
        }
    }
}
----

[[control-flow-max-method]]
[graphviz, control-flow-max-method, png]
.Control flow graph from the method in <<max-method>> 
....
digraph {
    start[shape=rectangle];
    end[shape=rectangle];
    start
    
    p1[label="a > b"];
    p2[label="a > c"];
    p3[label="b > c"];
    
    ra[label="result = a;"];
    rb[label="result = b;"];
    rc1[label="result = c;"];
    rc2[label="result = c;"];

    start -> p1 -> p2 -> ra;
    p2 -> rc1;
    p1 -> p3 -> rb;
    p3 -> rc2;

    ra -> end;
    rb -> end;
    rc1 -> end;
    rc2 -> end;
}
....

The cyclomatic number, or circuit rank of an undirected graph, is the minimum number of edges that has to be removed in order to break all cycles and obtain its spanning tree. The cyclomatic number stem:[v(G)] of a graph stem:[G] is computed as stem:[v(G) = E - V + 2P], where stem:[N] is the number of nodes, stem:[E] the number of edges and stem:[P] the number of connected components. If the graph is strongly connected, that is, there is a path from any node to any other node, then the cyclomatic number is equal to the maximum number of linearly independent circuits. The linearly independent circuits form a basis of all circuits in the graph. Therefore, all circuits in the graph are formed by a combinations of these linearly independent circuits. 

The cyclomatic complexity of a method is defined as the cyclomatic number of the underlying undirected graph of the control flow graph. 

McCabe showed that the computation of the  cyclomatic complexity could be simplified as the number of predicate nodes (conditionals) plus one. The method in <<max-method>> has a cyclomatic complexity of stem:[v(G) = 4 = 3 + 1], as it has three conditionals: `a > b`, `a > c` and `b > c`. It can be also computed as stem:[v(G) = 4 = 11 - 9 + 2], as it has eleven edges, nine nodes and only one connected component.

The cyclomatic complexity has implications for testing. It sets a lower bound for the number of inputs that should be used to test the method. Any execution path in the control flow graph of the method is a combination of the linearly independent circuits. Therefore, to ensure that the tests execute all conditions in the code, all linearly independent circuits should be used once in the executions paths of all inputs. The number of different test inputs must be greater or equal to the cyclomatic complexity of the method.

McCabe's cyclomatic complexity is well known and widely used. It is frequently accompanied by a scale. Usually values below 10 are considered as good. However, some caveats of the metrics must be considered. First, it was conceived for unstructured programs and some aspects of its original definition are vague. Modern tools implementing the metric work under different assumptions, therefore two different tools may not produce the same result for the same method. Logical conjunctions and disjunctions (`&&`, `||`) also produce branches. This must be taken into account to compute the value of the metric from the source code or, even better, compute the metric from compiled code.

Not always the cyclomatic complexity matches the developer's idea of what a complex and hard to understand method is. For example, the metric does not consider nested structures. It produces the same value for the two code fragments in <<ifs-mccabe>>.


[[ifs-mccabe, Listing {counter:listing}]]
.Listing {listing}. These two pieces of code have the same cyclomatic complexity
[source, java]
----
// 1 
if (a) {
    if (b) {
        ...
    }
    else {
        ...
    }
}
else {

}

//2
if(a) {
    ...
}
else {

}
if (b) {

}
else {

}
----

In <<hummel2014mccabe>>, the author advocates against the use of the metric. Besides showing concrete examples where tools produce different results, he shows the method in <<hummel-switch>>. The authors explain that this method is fairly easy to understand, yet it has a cyclomatic complexity of 14 while the more complex method in <<hummel-primes>> has a cyclomatic complexity of 5. 

[[hummel-switch, Listing {counter:listing}]]
.Listing {listing}. A simple method with a cyclomatic complexity of 14. Taken from <<hummel2014mccabe>>.
[source, java]
....
String getMonthName (int month) {
    switch (month) {
        case 0: return "January";
        case 1: return "February";
        case 2: return "March";
        case 3: return "April";
        case 4: return "May";
        case 5: return "June";
        case 6: return "July";
        case 7: return "August";
        case 8: return "September";
        case 9: return "October";
        case 10: return "November";
        case 11: return "December";
        default: 
            throw new IllegalArgumentException();
    }
}
....

[[hummel-primes, Listing {counter:listing}]]
.Listing {listing}. A relatively complex method with a cyclomatic complexity of 5. Taken from <<hummel2014mccabe>>.
[source, java]
....
int sumOfNonPrimes(int limit) {
    int sum = 0;
    OUTER: for (int i = 0; i < limit; ++i) {
        if (i <= 2) {
        	continue;
        }
        for (int j = 2; j < i; ++j) {
            if (i % j == 0) {
            	continue OUTER;
             }
        }
        sum += i;
    }
    return sum;
}
....

===== Coupling between objects or class coupling

A class is coupled to another if the former uses a method or a field from the latter. Coupling between classes can not be avoided, it is, in fact, desirable. We create classes as functionality units for reuse. At some point, existing classes will be leveraged to create new functionalities. However, coupling has important implications: changing a class most of the times will require changing its dependent classes. Therefore tight coupling between classes harms modularity, makes a software too sensitive to change and harder to maintain <<chidamber1994metrics>> <<fowler2001reducing>>.

_Class coupling_ or _Coupling Between Objects_ (CBO) of a class is the number of external classes it uses. In <<coupling-example>>, `Point` has CBO of 0.. It only depends on `double` and the metric does not count primitive types. `Line`, on the other hand, depends on `Point` and has a CBO of 1. The metric counts only unique classes. In the example, `Line` uses `Point` several times, but it is counted only once.

[[coupling-example, Listing {counter:listing}]]
.Listing {listing}. Two classes: `Point` as CB=0 coupling and `Line` 1.
[source, java]
....
class Point {

    private double x, y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return this.x;
    }

    public double getY() {
        return this.y;
    }

    public double dot(Point p) {
        return x*p.x + y*p.y;
    }

    public Point sub(Point p) {
        return new Point(x - p.x, y - p.y);
    }

}

class Segment {

    private Point a, b;

    public class Segment(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public boolean has(Point p) {
        Point pa = p.sub(a);
        Point ab = a.sub(b);
        double product = pa.dot(ab);
        return 0 <= product && product <= ab.dot(ab);
    }
}
....

Classes with low CBO values, or loosely coupled are easier to reuse. Classes with large CBO values or tightly coupled should be avoided and refactored. If a tightly coupled class is necessary, then these it requires rigorous testing to correctly verify its interaction with its dependencies. A study from 2010 performed on the Eclipse project concluded that, among other metrics, CBO is a significant predictor on how prone a class is to bugs. The same study says that a CBO greater than 9 signals a high risk to introduce a fault.

Coupling could measured not only at the class level but also between any modules that conform a system.

The _Law of Demeter_ (LoD)  or _principle of least knowledge_ is a guideline aiming to keep classes loosely coupled <<appleton_demeter>>. Its idea is that any unit should only "talk" to "its closest friends" and not to "strangers". In the context of object-oriented programming, it means that a method can only invoke methods from `this`, a parameter, an object instantiated in the method and an attribute of the class. <<demeter-example>> shows examples of violations of this principle.

[[demeter-example, Listing {counter:listing}]]
.Listing {listing}. Examples of violations of the Law of Demeter.
[source,java]
....
public class Foo {

    public void example(Bar b) {
       C c = b.getC(); //<1>
        
       c.doIt(); //<2>
        
       b.getC().doIt(); //<3>
        
       D d = new D(); 
       d.doSomethingElse(); //<4>
    }
}
....
<1> Conforms to LoD
<2> Violates LoD as `c` was not created inside `example`
<3> Chaining method invocations does not conform to LoD
<4> Conforms to LoD, as `d` was created inside the method

LoD also has downsides. A strict adherence to its postulates may produce many unnecessary wrapper methods. In <<demeter-example>> the class `Bar` should had a wrapper method `doItInC` whose code could be `this.getC().doIt()` or something alike. This kind of wrapper would be widespread in the code and it could become a challenge for maintenance. On the other hand, fluent APIs encourage the use of method chains, which also tend to improve readability. As with any principle, the use of LoD should be balanced.

===== Class cohesion

A class in an object-oriented program, or a module in general, is expected to have a responsibility over a single and well defined part of the software's functionalities. All services/methods of the module/class should be aligned with this responsibility and this responsibility should be entirely encapsulated in the class. This ensures that the module/class is only changed when the requirements concerning the specific responsibility change. Changes to different requirements should not make a single class to change <<martin2006agile>> <<martin2014single>>. This known as the The _Single Responsibility Principle_ was coined by Robert C. Martin in the late 1990's and is the *S* in the *SOLID* principles of object-oriented programming.

If a class violates this principle, then it can probably be divided in two or more classes with different responsibilities. In this case we say that the class lacks _cohesion_. In a more concrete view, a cohesive class performs different operations on the same set of instance variables <<chidamber1994metrics>>.

There are several metrics to evaluate cohesion in classes, but most of them are based in the _Lack of Cohesion Of Methods_ (LCOM) <<chidamber1994metrics>>. This metric is defined as follows:

Let stem:[C] be a class with stem:[n] methods: stem:[M_1, ..., M_n], let stem:[I_j] the set of instance variables used by the method stem:[M_j]. Let stem:[P = { (I_i, I_j) | I_i \cap I_j = \emptyset, i \gt j }], that is, the pairs of methods that use disjoint sets of instance variables, and stem:[Q = { (I_i, I_j) | I_i \cap I_j \ne \emptyset, i \gt j}], all pairs of methods using at least one instance variable in common. Then stem:[\text{LCOM}(C) = |P| - |Q| \text{ if } |P| \gt |Q| \text{ 0} \text{ otherwise}].

This means that _LCOM_ is equal to the number of pairs of methods using a disjoint set of instance variables minus the number of pairs of methods using variables in common. If the class has more methods using disjoint sets of instance variables then it is less cohesive. A class is cohesive if its methods use the same variables to compute different things. Low values of LCOM are preferred.

<<variables-methods-point>> shows the set of all instance variables used by each method declared in the `Point` class shown in <<coupling-example>>. Constructors are not used to compute this metric, as their role is to initialize the variables and they virtually access all of them. In this particular example, all methods use the instance variables directly. However, a method could use an instance variable indirectly by invoking other methods.  In that case, the variables are also said to be used by the initial method. For example, any new method invoking `getX` in `Point` would also use variable `x`.

[[variables-methods-point]]
. Set of instance variables used by each method of the class `Point` shown in <<coupling-example>>.
[options="header"]
|=== 

| Method | Instance variables  

| `getX` | { `x` }

| `getY` | { `y` }

| `dot` | { `x`, `y` }

| `sub` | { `x`, `y` }

|=== 

<<intersection-methods-point>> shows the instance variables used un common for all pairs of methods declared in `Point`. Only `getX` and `getY` do not use any variable in common.

[[intersection-methods-point]]
. Intersection of instance variables used by all pairs of methods in `Point`.
[options="header", cols="h,1,1,1"]
|===
|        | `getX`           | `getY`           | `dot`
| `sub`  | { `x` }          | { `y` }          | { `x`, `y` } 
| `dot`  | { `x` }          | { `y` }          h|
| `getY` | stem:[\emptyset] 2+h| 
|===

Given that we obtain: stem:[ | P | =  | \{ (I_\text{getX},I_\text{getY}) \} | = 1 ] and: stem:[ | Q | = | \{ (I_\text{getX},I_\text{sub}), (I_\text{getX},I_\text{dot}), (I_\text{getY},I_\text{sub}), (I_\text{getY},I_\text{dot}), (I_\text{dot},I_\text{sub}) \} | = 4] producing: stem:[ \text{LCOM}(C) = 0 ] as stem:[ | P | \lt | Q | ]. Which means that the `Point` class is cohesive, its carries the responsibility to represent the concept of a two-dimensional point. Only a change in the requirements of this representation will make this class change.

Lack of cohesion implies that a class violates the principle of single functionality and could be split in two different classes. <<cohesion-example>> shows the `Group` class. The only two methods in this class use a disjoint set of fields. `compareTo` uses `weight` while `draw` uses `color` and `name`. Computing the metric we get: stem:[\text{LCOM}(C = |P| - |Q| = 1 - 0 = 1].

[[cohesion-example, Listing {counter:listing}]]
.Listing {listing}. Example of a non-cohesive class. `compareTo` and `weight` could be separated from the rest.
[source, java]
....
class Group {

    private int weight;
    private String name;
    private Color color;

    public Group(String name, Color color, int weight) {
        this.name = name;
        this.color = color;
        this.weight = weight;
    }

    public int compareTo(Group other) {
        return weight - other.weight;
    }

    public void draw() {
        Screen.rectangle(color, name);
    }

}
....

__Tight Class Cohesion__ (TCC) and _Loose Class Cohesion_ (LCC) are other two well known and used metrics to evaluate the cohesion of a class <<bieman1995cohesion>>. Both these metrics start by creating a graph from the class. The graph is constructed as follows: Given a class `C`, each method `m` declared in the class becomes a node. Given any two pairs `m` and `n` declared in `C` we add an edge between `m` and `n` if and only if, `m` and `n` use at least one instance variable in common. Going back to the definition of `LCOM`, we add an edge between `m` and `n` if stem:[I_{m,n} \ne \emptyset]. TCC is defined as the ratio of directly connected pairs of node in the graph to the number or all pairs of nodes. On its side, LCC is the number of pairs of connected (directly or indirectly) nodes to all pairs of node. As before, constructors are not used.


<<cohesion-graph>> shows the graph that results from the class `Point`. In this example, stem:[\text{TCC = 5/6 = 0.83] as there are 5 direct connections and only 6 method pairs. On the other hand stem:[\text{LCC} = 6/6 = 1] as all pairs of methods are indirectly or directly connected. For the `Group` class both LCC and TCC are 0, as no method is connected to the other. 

[graphviz, cohesion-graph, png, layout=neato]
.Description
....
graph {
    rankdir=LR;
    getX[pos="0,1!"];
    dot[pos="1,0!"];
    sum[pos="1,2!"];
    getY[pos="2,1!"];
    getX -- sum[label=x] 
    getY -- sum[label=y];
    getX -- dot[label=x];
    getY -- dot[label=y];
    sum -- dot [label="x,y"];
}
....


In object-oriented programs a class may inherit methods and instance variables from its base classes. In those cases, computing the cohesion of a subclass may: include only inherited methods, only inherited fields, or both. The original definition of TCC and LCC leaves this inclusion open to the users of the metrics <<bieman1995cohesion>>.


=== Static analysis

Enforcing coding guidelines, detecting code smells and computing code metrics, can and *should be* automated. All these goals can be achieve by inspecting the code without executing the program. This is known as _static analysis_. Any form of static analysis takes as input the code of a program. It may be a high level code, such as Python, or Java, or it could also target compiled code as the JVM bytecode. The static inspection of code also enables the early detection of problems like cyclic dependencies, potential null pointer exceptions, buffer overflows. Since it does not require the execution of the program, static analysis is, in most cases, very efficient in terms of computation time.

There are plenty of available tools that can perform many types of static analysis. Some of them are highly configurable to, for example, select the coding guidelines a team wants to enforce. Many of these tools are also extensible and may allow the incorporation of new metrics, code smell definitions and other unforeseen functionalities. There are also libraries that make it easy to implement custom static analysis tools. This section presents some of these libraries and tools for Java.

==== Implementing a static analysis

Most code analyses start with the two same initial phases of a compiler, lexicographic and syntactic analysis.

Given a source code, say in Java as the one in <<static-analysis-example>>, lexicographical analyzer, lexer, or scanner, groups together sequences of characters. These sequences are usually are associated with a type  and are called _tokens_. The lexer produces as output a sequence of tokens.

[[static-analysis-example, Listing {counter:listing}]]
.Listing {listing}. A simple Java class.
[source, java]
....
class A {

    public void method() {
        System.out.println("Hello");
    }
}
....

<<tokens>> shows the first tokens produced by a lexer for the code in <<static-analysis-example>>. A lexer also removes character that are not needed for subsequent phases like white spaces and comments.


[[tokens, Listing {counter:listing}]]
.Listing {listing}. First tokens produced for <<static-analysis-example>>
....
("class", CLASS_KEYWORD)
("A", IDENTIFIER)
("{", "OPEN_BRACE")
("public", PUBLIC_KEYWORD)
("void", VOID_KEYWORD)
("method", IDENTIFIER)
....

The sequence of tokens is used as input for the syntactic analysis where a _parser_ checks that the order of the tokens is correct with respect to a formal specification or grammar and builds an _Abstract Syntax Tree_ (AST). An AST is a hierarchical representation of the source code. The nodes represent the elements in the code in a way that, for example, nodes representing classes have children representing methods and fields, and nodes representing methods contain nodes representing instructions. The AST does not contain purely syntactical elements such as semicolons or braces. <<ast-example>> shows a simplified version of an AST for the code in <<static-analysis-example>>.

[graphviz, ast-example, png]
.Description
....
graph {
    A -- method;
    method -- public, void, body
    body -- invocation
    invocation -- access, println, arguments
    access -- System, out
    arguments -- "\"Hello\""
}
....

//TODO: Link to GoF
Most static analyses are implemented by tracing the AST and most implementations are based on the visitor pattern. The visitor pattern abstracts the operations to be performed over an object structure <<gamma1994design>>. Each operation is implemented as a visitor. The structure is traversed and each visitor is selected according to the elements of the structure that is being visited. In the case of a static analysis over an AST, each visitor could be a class or a method, designed to operate over a specific type of node, for example, a class will be handled by a _class visitor_. The static analysis is then carried by the joint actions of these visitors.

//TODO: Link to Spoon, JavaParser and ASM
There are libraries that facilitate the implementation of static analyses by accomplishing the construction of the AST and even providing abstractions to implement the visitor pattern. For Java sources two of the most famous are http://spoon.gforge.inria.fr/[Spoon] and JavaParser. There are other libraries that offer similar functionalities but targeting compiled code. One most famous JVM bytecode analysis tool is https://asm.ow2.io/[ASM]. The following sections will show how to implement simple static analysis tasks in both Spoon and ASM.


===== Using Spoon

===== Using ASM

=== Tools for static analysis


////

TODO:


Explain that one could implement it or use an existing tool

Libraries to implement static analysis: Spoon
Examples on how to implement one simple metric or code smell detector

Present other forms of static analysis:
Maybe present this before talking about implementation?

Control flow analysis
    Cyclic dependencies
    Dead/unreachable code
Data flow analysis
    Uninitialized variables
    Buffer overflows
    Null pointers
API analysis
    Consistency between interface and implementation

Present tools:

Compilers: Errors prevent the creation of invalid programs, warnings help discover potential problems in type conversion as truncation errors, (remember the bugs from the previous classes), dead code elimination
Linters: Extended syntax analysis, original tool was Lint from Bell Labs for the Protable C Compiler for the PDP-11. Its role was to detect bad code patterns and patterns of code that would introduce incompatibilities among architectures. The the term expanded to similar tools.
Other tools to compute metrics and detect the occurrence of code patterns:
- PMD
- Findbugs
usually extensible and configurable. May analyze source code or compiled code.
Build your own?

Discuss limitations of static analysis

////


=== (Working title) How to incorporate in the development process

////
TODO:

- IDE: instant response, sometimes they also provide automatic fixing
- Make the build fail --> local environment or CI/CD
- Code reviews: Meetings, platforms
- CI/CD 
    --> SonarQube
    --> https://github.com/ankitvgupta/pycodestyle-action this posts the result of the  static analysis as a comment in the pull request
    --> Try to see an example of a check on code style in a pull request from Github/ Jenkins or Gitlab
////


:numbered!:
=== References

[start = {counter:references}]
. [[spinellis2006code,({references})]] Spinellis, D. (2006). Code quality: the open source perspective. Adobe Press.

. [[fowler2019is,({counter:references})]] Fowler M. (May 2019). Is High Quality Software Worth the Cost? https://martinfowler.com/articles/is-quality-worth-cost.html Last accessed: 22/04/2020

. [[boehm1976quantitative,({counter:references})]] Boehm, B. W., Brown, J. R., & Lipow, M. (1976, October). Quantitative evaluation of software quality. In Proceedings of the 2nd international conference on Software engineering (pp. 592-605). IEEE Computer Society Press. https://dl.acm.org/citation.cfm?id=807736

. [[iso2011square,({counter:references})]] ISO/IEC 25010:2011 Systems and software engineering — Systems and software Quality Requirements and Evaluation (SQuaRE) — System and software quality models. https://www.iso.org/standard/35733.html Last accessed: 22/04/2020

. [[oracle1997java, ({counter:references})]] Oracle (1997). Java Code Conventions https://www.oracle.com/technetwork/java/codeconventions-150003.pdf Last accessed: 28/04/2020

. [[microsoft2008naming, ({counter:references})]] Microsoft (2008). Names of Classes, Structs, and Interfaces https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-classes-structs-and-interfaces Last accessed: 28/04/2020

. [[vanrossum2001style, ({counter:references})]] van Rossum G. (2001). Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/ Last accessed: 29/04/2020

. [[wikipedia2020indentation, ({counter:references})]] Wikipedia. Indentation style. https://en.wikipedia.org/wiki/Indentation_style Last accessed: 30/04/2020

. [[microsoft2018secure, ({counter:references})]] Microsoft (2018). Secure coding guidelines. https://docs.microsoft.com/en-us/dotnet/standard/security/secure-coding-guidelines Last accessed: 30/04/2020

. [[google2020java, ({counter:references})]] Google. Google Java Style Guide. https://google.github.io/styleguide/javaguide.html Last accessed: 30/04/2020

. [[fowler2006codesmell, ({counter:references})]] Forwler. M. (2006). CodeSmell https://martinfowler.com/bliki/CodeSmell.html Last accessed: 01/05/2020

. [[source2020smells, ({counter:references})]] Source Making. Code Smells https://sourcemaking.com/refactoring/smells Last accessed: 01/05/2020

. [[source2020anti, ({counter:references})]] Source Making. AntiPatterns. https://sourcemaking.com/antipatterns Last accessed: 30/04/2020

. [[glover2006monitoring, ({counter:references})]] Glover A. (2006). Monitoring Cyclomatic Complexity. https://www.ibm.com/developerworks/library/j-cq03316/index.html Last accessed: 05/05/2020

. [[mcloone2012code, ({counter:references})]] McLoone J. (2012). Code Length Measured in 14 Languages https://blog.wolfram.com/2012/11/14/code-length-measured-in-14-languages/ Last accessed: 15/06/2020

. [[mccabe1976complexity, ({counter:references})]] McCabe, T. J. (1976). A Complexity Measure. IEEE Transaction on Software Engineering, vol SE-2(4).

. [[hummel2014mccabe, ({counter:references})]] Hummel B. (2014) McCabe's Cyclomatic Complexity and Why We Don't Use It. https://www.cqse.eu/en/news/blog/mccabe-cyclomatic-complexity/ Last accessed: 17/06/2020

. [[chidamber1994metrics, ({counter:references})]]  Chidamber, S. R., & Kemerer, C. F. (1994). A metrics suite for object oriented design. IEEE Transactions on software engineering, 20(6), 476-493. Online: http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf Last accessed: 18/06/2020

. [[fowler2001reducing, ({counter:references})]] Fowler, M. (2001). Reducing Coupling. IEEE Softw., 18, 102-104. Online: https://martinfowler.com/ieeeSoftware/coupling.pdf Last accessed 18/06/2020

. [[appleton_demeter, ({counter:references})]] Appleton B. Introducing Demeter and its Laws. http://www.bradapp.com/docs/demeter-intro.html Last accessed 18/06/2020

. [[martin2006agile, ({counter:references})]]  Martin, R. C., & Martin, M. (2006). Agile principles, patterns, and practices in C# (Robert C. Martin). Prentice Hall PTR. Online: https://ivanderevianko.com/wp-content/uploads/2013/10/Agile-Principles-Patterns-and-Practices-in-C.pdf Last accessed: 19/06/2020

. [[martin2014single, ({counter:references})]] Martin, R.  (2014) The Single Responsibility Principle https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html Last accessed: 19/06/2020

. [[bieman1995cohesion, ({counter:references})]] Bieman, J. M., & Kang, B. K. (1995). Cohesion and reuse in an object-oriented system. ACM SIGSOFT Software Engineering Notes, 20(SI), 259-262.

. [[gamma1994design, ({counter:references})]]  Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns Elements of reusable object-oriented sofware. Addison Wesley.