:numbered:
== Code quality and static analysis

The goal of any software project is to deliver a product of the highest possible quality, or at least it should be. Good software has scarce bugs. However, the notion of quality also characterizes how the product is being built and structured. Observing these aspects should help, in the end, to avoid the introduction of bugs. Diomidis Spinellis in his book _Code Quality: The Open Source Perspective_ <<spinellis2006code>> presents four views of software quality:

Quality in use:: This view is centered in the user experience, that is, how users perceive the software. It is the extent to which users can achieve their goals in a particular environment. It does not care about how the product is built. If a word processor makes it hard to edit a document, then it does not serve it purposes.
External quality attributes:: These attributes manifest themselves in the execution of the program. They characterize how well the product conforms to the specification. Observed failures signal the presence of bugs. Crashes, efficiency problems and alike degrade the external quality fo the software. External quality attributes directly affect the quality in use.
Internal quality attributes:: They characterize the internal structure of the product. According to Martin Fowler, <<fowler2019is>>, internal software quality is impacted by how easy it is to understand the code. This, in turn, impacts how easy it is to maintain the product, add new features, improve and detect errors. Internal quality has a great impact in the external quality of the software.
Process quality:: It is a direct expression of how the software product was built. It is affected by the methodologies, practices. tools, frameworks used to develop the software. A good development process favors actions that improve the internal quality of the product.

In the end, all views of quality are deeply interconnected. The process quality impacts the internal quality. The internal quality affects in turn the external quality which directly affects the user experience.

Several models of software quality attributes have been proposed and standardized throughout the years <<boehm1976quantitative>>, <<iso2011square>>. However they all insist, as the Consortium for IT Software Quality (CISQ) summarizes, that high quality software products must be: 
*reliable* (low risk level in use and low likelihood of potential failures), *efficient*, *secure*, and *maintainable*.

Martin Fowler <<fowler2019is>> explains that, as time goes by and a project becomes more complex, it is harder to add new features. At this point, even small changes require programmers to understand large areas of code. Paying attention to internal quality is crucial to further develop the product. Fowler calls _cruft_ those deficiencies in internal quality that make it harder to modify and extend the system. _Crufts_ are redundant, useless and dysfunctional pieces of code that become obstacles and increase increase maintenance costs. This is also known as _Technical Debt_.

External quality attributes can be observed and improved with the help of testing. Meanwhile internal quality attributes are observed by analyzing the code without executing it, that is, with the help of static code analysis. Some authors consider static analysis as a form of _static testing_. However, Meyer in its principles <<meyer2008seven>> excludes these techniques from the testing umbrella. Either way, static analysis helps to spot potential problems earlier and therefore impacts the testing process.

=== Code quality

Internal quality is assured by good code and good development practices. Good code is easy to understand and maintain. But, what may be easy to understand for one developer might be hard to understand for another, and even for the same developer two weeks after the code was written. Fortunately, the community has gathered and shared practices shown to work well, or not, according to experience. 

==== Coding guidelines

Some good development practices are presented as _coding guidelines_ or _coding conventions_. These are rules that specify how the code should be written so it can be understood by everyone. They may go from how to name a class or a method and how to handle exceptions to how and when to insert blank spaces in the code.

Coding guidelines may be specific to a programming language, to a particular framework, library, or tool, they may even be specific to a company or even a project. There are also guidelines general enough so they could be applied anywhere or guidelines that pursue an specific goal such as reducing security breaches in a program.

===== Naming conventions

[quote, Phil Karlton,  Product Architect at Netscape]
____
There are only two hard things in Computer Science: cache invalidation and naming things.
____ 

Part of the coding guidelines is devoted to help developers know how to name program elements such as classes or methods. These guidelines are different from one language to the other, although they share common ideas. This section contains three examples from Java, C# and Python.

The following <<java-naming-conventions>> is an extract from the Java coding conventions <<oracle1997java>>. This fragment specifies how developers should name classes, interfaces and methods.

[[java-naming-conventions]]
.Java naming conventions for classes, interfaces and methods
====
Class names should be nouns, in mixed case with the first letter of each internal word capitalized. Try to keep your class names simple
and descriptive. Use whole words—avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the
long form, such as URL or HTML).

Interface names should be capitalized like class names.

Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
====

<<java-naming-example>> shows a piece of code respecting the naming conventions form <<java-naming-conventions>>.

[[java-naming-example, Listing {counter:listing}]]
.Listing {listing}. Java code matching naming conventions for classes, interfaces and methods
[source,java]
----
public class ArrayList extends AbstractList implements RandomAccess {
    public void ensureCapacity(int minCapacity) { ... }
}
----

<<csharp-naming-conventions>> contains an extract of the naming conventions for C# <<microsoft2008naming>>. 

[[csharp-naming-conventions]]
.C# naming conventions
====
✔️ DO name classes and structs with nouns or noun phrases, using PascalCasing. This distinguishes type names from methods, which are named with verb phrases.

✔️ DO name interfaces with adjective phrases, or occasionally with nouns or noun phrases.

❌ DO NOT give class names a prefix (e.g., "C").

...

✔️ DO prefix interface names with the letter I, to indicate that the type is an interface.

✔️ DO ensure that the names differ only by the "I" prefix on the interface name when you are defining a class–interface pair where the class is a standard implementation of the interface.
====

There are similarities between the naming conventions for Java and C#. For example, class names should be noun phrases starting with a capital letter and using _PascalCasing_ (Also called _UpperCamelCase_ or _DromedaryCase_). While method names in both languages should be verb phrases indicating an action, in Java developers use _camelCasing_. Notice that, in C#, interfaces should be prefixed with `I` but classes should not be prefixed with `C`. <<csharp-naming-example>> shows a code fragment matching these naming conventions. The `I` prefix helps to quickly differentiate between classes and interfaces.

[[csharp-naming-example, Listing {counter:listing}]]
.Listing {listing}. C# code respecting naming conventions
[source,csharp]
----
public class ComplexNode : Node, IEnumerable {
    public void RemoveNode(Node node) { ... }
}
----

Python developers use conventions to further differentiate method and functions from classes and user defined classes from built-in types <<vanrossum2001style>>. See <<python-naming-conventions>>.

[[python-naming-conventions]]
.Naming conventions for Python
====
Class names should normally use the CapWords convention.
The naming convention for functions may be used instead in cases where the interface is documented and used primarily as a callable.

Note that there is a separate convention for builtin names: most builtin names are single words (or two words run together), with the CapWords convention used only for exception names and builtin constants.

Function names should be lowercase, with words separated by underscores as necessary to improve readability.
====

With this, one can easily infer that `Node` names a class, `str` is a built-in type and `remove_node` is a function.

===== Indentation

In most language extra white spaces do not change the semantics of a program but sure they play an important role in readability. Each language tries to enforce an indentation style, but even for the same language different developers have follow different styles. Keeping a consistent style helps fast delimiting blocks in a program and improves understanding.

<<indentation-examples>> shows three examples of different indentation styles applied to the same fragment of code. Notice how different the program looks in each case.

[[indentation-examples]]
.Examples of indentation styles taken from https://en.wikipedia.org/wiki/Indentation_style[Wikipedia] <<wikipedia2020indentation>>
[cols="a,a,a"]
|===
| *Kernighan & Ritchie*
[source,c]
----
while (x == y) {
    something();
    somethingelse();
}
----
| *Ratliff*
[source,c]
----
while (x == y) {
    something();
    somethingelse();
    }
----
| *Haskell*
[source,c]
----
while (x == y)
  { something()
  ; somethingelse()
  ; 
  }
----
|===

The _Kernighan & Ritchie_ style, also known as "`_the one true brace style_`" and "`Egyptian braces`" was used in the influential book _The C Programming Language_ written by Brian Kernighan and Dennis Ritchie (creator of C). Besides C, this style is also used in C++ and Java. C# however, uses the Allman style, in which the first brace is written in a separated line. The Allman style is also used in Pascal and SQL.

Wikipedia lists nine different indentation styles most of them with additional variants <<wikipedia20202indentation>>.

===== Framework and company specific guidelines

Companies and even communities around a framework or project may impose specific guideline to override or extend language conventions.

Sometimes these guidelines have a concrete goal other than readability. <<microsoft-security-example>> shows an extract of the guidelines Microsoft enforces to write secure code using the .NET framework <<microsoft2018secure>>.

[[microsoft-security-example]]
.Microsoft's secure coding guidelines for the .NET framework.
====
When designing and writing your code, you need to protect and limit the access that code has to resources, especially when using or invoking code of unknown origin. So, keep in mind the following techniques to ensure your code is secure:

- Do not use Code Access Security (CAS).
- Do not use partial trusted code.
- Do not use the AllowPartiallyTrustedCaller attribute (APTCA).
- Do not use .NET Remoting.
- Do not use Distributed Component Object Model (DCOM).
- Do not use binary formatters.
====

<<google-conventions>> shows how Google extends the Java coding conventions to their own projects <<google2020java>>.

[[google-conventions]]
.Google conventions for Java
====
When a reference to a static class member must be qualified, it is qualified with that class's name, not with a reference or expression of that class's type.
[source, java]
----
Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very bad
----
====

===== Should conventions be always enforced?

Conventions are created to set a common ground for understanding. This is specially useful when learning a new language, for a newcomer and to ease the collaboration between different developers in a project. However, there are cases in which strictly following these conventions actually has the opposite effect. For example, when dealing with legacy code that followed different guidelines, it is better to stick to the practices in place rather than introducing new conventions. 

In any case, the ultimate goal must be to write consistent code that can be understood for all team/project members. Common sense is always the best guideline.

<<microsoft-base-name>> explains how to name extending classes with respect to the base class, but it also wars against over-use <<microsoft2008naming>>.

[[microsoft-base-name]]
.Microsoft's guideline to name extending classes with a warning on when not to use it 
====
✔️ CONSIDER ending the name of derived classes with the name of the base class.

This is very readable and explains the relationship clearly. Some examples of this in code are: ArgumentOutOfRangeException, which is a kind of Exception, and SerializableAttribute, which is a kind of Attribute. However, it is important to use reasonable judgment in applying this guideline; for example, the Button class is a kind of Control event, although Control doesn’t appear in its name.
====

<<python-guidelines-warning>> shows an extract from the Python coding guidelines stressing the idea that keeping consistency is more important than following the guidelines <<vanrossum2001style>>.

[[python-guidelines-warning]]
.Python guidelines on consistency and guidelines applications
====
A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.

However, know when to be inconsistent -- sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask!

In particular: do not break backwards compatibility just to comply with this PEP!
====

==== Code Smells and AntiPatterns

Thorough the years, developers have identified patterns of code that usually become symptoms of hidden problems affecting the quality of the software. Such code patterns are known as _Code Smells_, a term coined by Kent Beck and first presented in Martin Fowler's _Refactoring_ book <<fowler2006codesmells>>.

Code smells do not always lead to a problem or a bug. But, in most, cases, their presence makes the code harder to understand and maintain, and in Fowler's words "`they are often an indicator of a problem rather than the problem themselves`". Code smells can be eliminated by refactoring, that is, restructuring the program to make it simpler.

The https://sourcemaking.com/[Source Making Blog] presents a list of well known code smells and how they could be solved <<source2020smells>>. Internet is full with such lists they might differ on the (generally catchy) name they use to categorize a smell and some might miss one or two patters.

The following is a small sample of that list.

Long method:: A method that contains too many lines of code or too many statements. Long methods tend to hide unwanted duplicated code and are harder to maintain. It can be solved by splitting the code in shorter methods easier to reuse, maintain and understand. <<long-method-example>> shows a fragment taken from <<glover2006monitoring>> of nearly 20 lines of code. It is already a big chunk code, but it comes for a very large method of more than 350 lines. This is a clear, and rather extreme example of this code smell.
+
[[long-method-example, Listing {counter:listing}]]
.Listing {listing}. An already large fragment of code from a method of more than 350 lines. Taken from <<glover2006monitoring>>
[source, java]
----
if (entityImplVO != null) {
  List actions = entityImplVO.getEntities();
  if (actions == null) {
     actions = new ArrayList();
  }
  Iterator enItr = actions.iterator();
  while (enItr.hasNext()) {
    entityResultValueObject arVO = (entityResultValueObject) actionItr
     .next();
    Float entityResult = arVO.getActionResultID();
    if (assocPersonEventList.contains(actionResult)) {
      assocPersonFlag = true;
    }
    if (arVL.getByName(
      AppConstants.ENTITY_RESULT_DENIAL_OF_SERVICE)
         .getID().equals(entityResult)) {
      if (actionBasisId.equals(actionImplVO.getActionBasisID())) {
        assocFlag = true;
      }
    }
    if (arVL.getByName(
     AppConstants.ENTITY_RESULT_INVOL_SERVICE)
      .getID().equals(entityResult)) {
     if (!reasonId.equals(arVO.getStatusReasonID())) {
       assocFlag = true;
     }
   }
 }
}else{
  entityImplVO = oldEntityImplVO;
}
----

Large class:: A class containing too many methods, fields and lines of code. Large classes can be split into several classes and even into a hierarchy in which each smaller class has a very well defined purpose.

Long parameter list:: A method with a long list of parameters is harder to use. Parameters could be replaced by method calls or passing complete objects.

Primitive obsession:: Abuse of primitive types instead of creating one's own abstractions.

Temporary fields:: Fields in classes that are used only under certain circumstances in one or very few methods, otherwise they are not used. These fields could be promoted most of the times to local variables.

Feature envy:: A method that accesses the data of another object more than its own data. This method's behavior will probably better placed in the class of the external object.

Code smells are very well localized program fragments. However, there are more global patterns that are often used as solutions to a problem but they may bring more harm than benefits and are better to avoid. These bad solutions are described as _AntiPatterns_. The same https://sourcemaking.com/[Source Making Blog] provides an interesting list of them AntiPatterns can be related to coding practices, software architecture designs and even related to the management of a project. Identifying these bad solutions helps also in finding a better alternative <<source2020anti>>.

Here are some examples:

Golden Hammer:: Using a single tool to solve most problems even when it is not the best alternative. Leads to inferior performance and less suited solutions, requirements are accommodated more to match the tool than what users may need, design choices are dictated by the tool's capabilities and new development relies heavily in the tool.

Cut-And-Paste Programming:: This one is self-descriptive: code is reused by copying and pasting fragments in different places. In the case that the originally copied code has a bug, then the issue will reoccur in all places where the code was pasted and it will be harder to solve.

Swiss Army Knife:: An excessively complex class interface attempting to provide for all possible uses of the class. These classes include too many method signatures for a single class. It denotes an unclear abstraction or purpose.

Design By Committee:: A software design, usually from a committee, is so complex and so full of different features and variants that it becomes impossible to complete in a reasonable lapse of time.

==== Code Metrics

Many code smells are vague in their formulation. For example: How can we tell that a method or a class is too long that should be split? Or, how can we tell that two classes are too coupled together so their functionalities should be merged or rearranged? The identification of such potential issues requires concrete measurements for the method length or the coupling between classes. These are known as _code metrics_.

Code metrics are quantitative characterizations or features of the code. They help to assess the structural quality of the software and provide an effective and customizable way to automate the detection of potential code issues. Metrics help to improve the development process.

===== Lines of Code

The simplest code metric is, maybe, the number of _Lines of Code_ (LoC) of a method.footnote:[Sometimes code metrics are presented for _operations_ instead of methods. _Operations_ are indeed methods but the term is broader to escape from the Object-Oriented terminology and reach other programming paradigms.] 

LoCs can be used to compare the length of the methods in a project. It helps to detect those methods that are too long when compared to a given threshold. However, this threshold depends on the development practices used for the project. The programming language as well as the frameworks and libraries supporting the code do have an impact on the length of the methods. For example, a small study made by Jon McLoone from Wolfram <<mcloone2012code>>, observed in http://rosettacode.org/wiki/Rosetta_Code[Rosetta Code] programs that _Mathematica_ requires _less than a third of the length of the same tasks written in other languages_.

Including blank lines or lines with comments in the metric may be misleading for its purposes. Therefore, LoC is often referred as _Physical Lines of Code_ while developers also measure _Logical Lines of Code_ (LLoC) which counts the number of programming language statements in the method. 

===== Cyclomatic Comprexity

A method with many branches and logical decisions is, in general, hard to understand. This affects the maintainability of the code. Back in 1976, Thomas J. McCabe  proposed a metric to assess the complexity of a program <<mccabe1976complexity>>. McCabe's original idea was to approximate the complexity of a program by computing the _cyclomatic number_ of its control flow graph. This is why the metric is also known as _McCabe's Cyclomatic Complexity_. The goal of the metric was to provide a quantitative basis to determine whether a software module was hard to understand, maintain and test.
 
A sequence of code instructions, and by extension the body of a method, could be represented by a directed graph named _control flow graph_. The procedure is as follows:
 - A sequence of instructions with no branches is called a _basic block_. Each basic block becomes a node of the graph.
 - Each branch in the code becomes an edge. The direction of edge coincides with the direction of the branch.

For example, the method in <<max-method>> computes the maximum of three given integers. The control flow for this method is shown in <<control-flow-max-method>>.

[[max-method, Listing {counter:listing}]]
.Listing {listing}. A method that computes the maximum between three given integers
[source, java]
----
public static int max(int a, int b, int c) {
    int result;
    if (a > b) {
        if(a > c) {
            result = a;
        }
        else {
            result = c;
        }
    }
    else {
        if (b > c) {
            result = b;
        }
        else {
            result = c;
        }
    }
    return result;
}
----

[[control-flow-max-method]]
[graphviz, control-flow-max-method, png]
.Control flow graph from the method in <<max-method>> 
....
digraph {
    n1[label="int result;\na > b"];
    n2[label="a > c"];
    n3[label="b > c"];
    n4[label="result = a;"];
    n5[label="result = b;"];
    n6[label="result = c;"];
    n7[label="result = c;"];
    n8[label="return result;"]

    n1 -> n2 -> n4;
    n2 -> n5;
    n1 -> n3 -> n6;
    n3 -> n7;
    n4 -> n8;
    n5 -> n8;
    n6 -> n8;
    n7 -> n8;
}
....

The cyclomatic number, or circuit rank of an undirected graph, is the minimum number of edges that has to be removed in order to break all cycles and obtain its spanning tree. The cyclomatic number stem:[v(G)] of a graph stem:[G] is computed as stem:[v(G) = E - V + 2P], where stem:[N] is the number of nodes, stem:[E] the number of edges and stem:[P] the number of connected components. If the graph is strongly connected, that is, there is a path from any node to any other node, then the cyclomatic number is equal to the maximum number of linearly independent circuits. The linearly independent circuits form a basis of all circuits in the graph. Therefore, all circuits in the graph are formed by a combinations of these linearly independent circuits. 

The cyclomatic complexity of a method is the cyclomatic number of the underlying undirected graph of the control flow graph. If required, the control flow graph could be extended by adding fictitious start and end nodes so the graph has only one entry point and only one exit point. 

McCabe showed that the computation of the  cyclomatic complexity could be simplified as the number of predicate nodes (conditionals) plus one. The method in <<max-method>> has a cyclomatic complexity of stem:[v(G) = 4 = 3 + 1], as it has three conditionals: `a > b`, `a > c` and `b > c`. It can be also computed as stem:[v(G) = 4 = 10 - 8 + 2], as it has 10 edges and eight nodes.

The cyclomatic complexity has implications for testing. It sets a lower bound for the number of inputs that should be used to test the method. Any execution path in the control flow graph of the method is a combination of the linearly independent circuits. Therefore, to ensure that the tests execute all conditions in the code, all linearly independent circuits should be used once in the executions paths of all inputs. The number of different test inputs must be greater or equal to the cyclomatic complexity of the method.

McCabe's cyclomatic complexity is well known and widely used. It is frequently accompanied by a scale. Usually values below 10 are considered as good. However, some caveats of the metrics must be considered. First, it was conceived for unstructured programs and some aspects of its original definition are vague. Modern tools implementing the metric work under different assumptions, therefore two different tools may not produce the same result for the same method. Logical conjunctions and disjunctions (`&&`, `||`) also produce branches. This must be taken into account to compute the value of the metric from the source code or, even better, compute the metric from compiled code.

Not always the cyclomatic complexity matches the developer's idea of what a complex and hard to understand method is. For example, the metric does not consider nested structures. It produces the same value for the two code fragments in <<ifs-mccabe>>.


[[ifs-mccabe, Listing {counter:listing}]]
.Listing {listing}. These two pieces of code have the same cyclomatic complexity
[source, java]
----
// 1 
if (a) {
    if (b) {
        ...
    }
    else {
        ...
    }
}
else {

}

//2
if(a) {
    ...
}
else {

}
if (b) {

}
else {

}
----

In <<hummel2014mccabe>>, the author advocates against the use of the metric. Besides showing concrete examples where tools produce different results, he shows the method in <<hummel-switch>>. The authors explain that this method is fairly easy to understand, yet it has a cyclomatic complexity of 14 while the more complex method in <<hummel-primes>> has a cyclomatic complexity of 5. 

[[hummel-switch, Listing {counter:listing}]]
.Listing {listing}. A simple method with a cyclomatic complexity of 14. Taken from <<hummel2014mccabe>>.
[source, java]
....
String getMonthName (int month) {
    switch (month) {
        case 0: return "January";
        case 1: return "February";
        case 2: return "March";
        case 3: return "April";
        case 4: return "May";
        case 5: return "June";
        case 6: return "July";
        case 7: return "August";
        case 8: return "September";
        case 9: return "October";
        case 10: return "November";
        case 11: return "December";
        default: 
            throw new IllegalArgumentException();
    }
}
....

[[hummel-primes, Listing {counter:listing}]]
.Listing {listing}. A relatively complex method with a cyclomatic complexity of 5. Taken from <<hummel2014mccabe>>.
[source, java]
....
int sumOfNonPrimes(int limit) {
    int sum = 0;
    OUTER: for (int i = 0; i < limit; ++i) {
        if (i <= 2) {
        	continue;
        }
        for (int j = 2; j < i; ++j) {
            if (i % j == 0) {
            	continue OUTER;
             }
        }
        sum += i;
    }
    return sum;
}
....

===== Class cohesion and coupling

////

TODO: 

Define both metrics
Show examples,
Discuss values
Explain Demeter's Law

////


=== (Working title) Static analysis


////

TODO:

Present a common workflow for static analysis: lexer, parser, AST
Explain that static analysis could inspect compiled code as well
Explain the visitor pattern as a form of implementation

Explain that one could implement it or use an existing tool

Libraries to implement static analysis: Spoon
Examples on how to implement one simple metric or code smell detector

Present other forms of static analysis:
Maybe present this before talking about implementation?

Control flow analysis
    Cyclic dependencies
    Dead/unreachable code
Data flow analysis
    Uninitialized variables
    Buffer overflows
    Null pointers
API analysis
    Consistency between interface and implementation

Present tools:

Compilers: Errors prevent the creation of invalid programs, warnings help discover potential problems in type conversion as truncation errors, (remember the bugs from the previous classes), dead code elimination
Linters: Extended syntax analysis, original tool was Lint from Bell Labs for the Protable C Compiler for the PDP-11. Its role was to detect bad code patterns and patterns of code that would introduce incompatibilities among architectures. The the term expanded to similar tools.
Other tools to compute metrics and detect the occurrence of code patterns:
- PMD
- Findbugs
usually extensible and configurable. May analyze source code or compiled code.
Build your own?

Discuss limitations of static analysis

////


=== (Working title) How to incorporate in the development process

////
TODO:

- IDE: instant response, sometimes they also provide automatic fixing
- Code reviews: Meetings, platforms
- Make the build fail --> local environment or CI/CD
- CI/CD 
    --> SonarQube
    --> https://github.com/ankitvgupta/pycodestyle-action this posts the result of the  static analysis as a comment in the pull request
    --> Try to see an example of a check on code style in a pull request from Github/ Jenkins or Gitlab
////


:numbered!:
=== References

[start = {counter:references}]
. [[spinellis2006code,({references})]] Spinellis, D. (2006). Code quality: the open source perspective. Adobe Press.

. [[fowler2019is,({counter:references})]] Fowler M. (May 2019). Is High Quality Software Worth the Cost? https://martinfowler.com/articles/is-quality-worth-cost.html Last accessed: 22/04/2020

. [[boehm1976quantitative,({counter:references})]] Boehm, B. W., Brown, J. R., & Lipow, M. (1976, October). Quantitative evaluation of software quality. In Proceedings of the 2nd international conference on Software engineering (pp. 592-605). IEEE Computer Society Press. https://dl.acm.org/citation.cfm?id=807736

. [[iso2011square,({counter:references})]] ISO/IEC 25010:2011 Systems and software engineering — Systems and software Quality Requirements and Evaluation (SQuaRE) — System and software quality models. https://www.iso.org/standard/35733.html Last accessed: 22/04/2020

. [[oracle1997java, ({counter:references})]] Oracle (1997). Java Code Conventions https://www.oracle.com/technetwork/java/codeconventions-150003.pdf Last accessed: 28/04/2020

. [[microsoft2008naming, ({counter:references})]] Microsoft (2008). Names of Classes, Structs, and Interfaces https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-classes-structs-and-interfaces Last accessed: 28/04/2020

. [[vanrossum2001style, ({counter:references})]] van Rossum G. (2001). Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/ Last accessed: 29/04/2020

. [[wikipedia2020indentation, ({counter:references})]] Wikipedia. Indentation style. https://en.wikipedia.org/wiki/Indentation_style Last accessed: 30/04/2020

. [[microsoft2018secure, ({counter:references})]] Microsoft (2018). Secure coding guidelines. https://docs.microsoft.com/en-us/dotnet/standard/security/secure-coding-guidelines Last accessed: 30/04/2020

. [[google2020java, ({counter:references})]] Google. Google Java Style Guide. https://google.github.io/styleguide/javaguide.html Last accessed: 30/04/2020

. [[fowler2006codesmell, ({counter:references})]] Forwler. M. (2006). CodeSmell https://martinfowler.com/bliki/CodeSmell.html Last accessed: 01/05/2020

. [[source2020smells, ({counter:references})]] Source Making. Code Smells https://sourcemaking.com/refactoring/smells Last accessed: 01/05/2020

. [[source2020anti, ({counter:references})]] Source Making. AntiPatterns. https://sourcemaking.com/antipatterns Last accessed: 30/04/2020

. [[glover2006monitoring, ({counter:references})]] Glover A. (2006). Monitoring Cyclomatic Complexity. https://www.ibm.com/developerworks/library/j-cq03316/index.html Last accessed: 05/05/2020

. [[mcloone2012code, ({counter:references})]] McLoone J. (2012). Code Length Measured in 14 Languages https://blog.wolfram.com/2012/11/14/code-length-measured-in-14-languages/ Last accessed: 15/06/2020

. [[mccabe1976complexity, ({counter:references})]] McCabe, T. J. (1976). A Complexity Measure. IEEE Transaction on Software Engineering, vol SE-2(4).

. [[hummel2014mccabe, ({counter:references})]] Hummel B. (2014) McCabe's Cyclomatic Complexity and Why We Don't Use It. https://www.cqse.eu/en/news/blog/mccabe-cyclomatic-complexity/ Last accessed: 17/06/2020


Code Metrics – Class Coupling https://docs.microsoft.com/en-us/archive/blogs/zainnab/code-metrics-class-coupling